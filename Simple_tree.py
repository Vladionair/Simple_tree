gAAAAABfUiCkd1h7M81ihS7CxNB4Kp_xFONN1EDNsV65taHPfKUBZmixjpSOptv7wd8lNwSmj_QpMv1U3XWsNn84wcprDOWAGlnADsrMqXcfWgUO3t_7Ztq72KbTiwBHks8OF17CXhGRsF9V2YVkYg2J3oHM2emwQ5I3DhKVMHJtjBlt2KMGTiStmwquM2TR6rjGeaeMs43PUkQ59sFFWKIOL8eMXcWfjAzSh3UoXl1hTUUM-JMwcWexQJsKgHDFhJ2bKmDGtwgl0LavcmRX62xC3cdUfOnngmoqooCIDRoehqpJXuoII5-2MmS0tpcWnqhrWB470eUFj7yqrj1Lf2ey3uDgq6oIlRqMet22jHQwM7AdQg1YSCxSD5HQLHl6TLtVJthegp8Nb6Rm940tJSbVN9FuFkx6imnoRkZWWjGN7Qe_Ga1cMmIn7X7rEyYPwceIUTugsMJ_0nxTekpvWNAOZI5nZV0OlleMpLv6V-GdDWT1TcyrYv3k1xsVYOd1fredbSwG4M10HVttzCm1l_6zJ7LqgVUn4APy8tCw16sxQV2L0V147Tptb2wBXsVnk3659YBRdX5edlW7HCmV2Zog484TVRW1hkhxHcNUSyKewA6VxmQPXwF8hfEQq9ARjciZ7634OC1jkxXA4-XkPsm8X3HIcB-0RG3C8dUxEP5xD3o7b2MZQVqXEt0vLnqFpolqF_ftYocsylOtP5DSNGavC7DtpWoCM0Jb4CXC7B8K2oIZYW6QKTZHJXFCpQ_X5hshRx736qICG9Qfe3rqEVhmreI1t88hnoi6TlkEarXrlnLmw7JhQBRJdFawdELJ9dfPgq65WsCqTA8hFYF1gpVl-O2WKk4UFJgRLZ4_qJ2EPuBGGSXJ0Azc2g0cdFY9BCZaodBFchZoYzFSnbk_uBoQ080GeSzcYL9EINfQC-XbIrw-Sr5k3RpCXk1y1E3wffDBl78m1Qrr3-LeQQcYhWE0gdS_tJS4qjOL6zfW7dXbXJ8VcaHZJ5YR4nAwihsa9qHKd-UNhmAsYpZfeGha_dF1vldtyjxCH0JgT-n-TRDQiiacY_2VdgQw_SSF-Zk4CNtLnPmSnuXS2f5dqnPPduW4mKpxRAy-OkWqonNVpHsYcLZOZzhmxxNjSIrxXIgvNJLrMJC4cIYsjVco81qyHpRdowMrS3BCtNW9zLCrnp0EB-ilaQSp7jPlery9rd4hBHxjf5j6CG5tyL4dPk1LNEhA3HnLU3ykYo4atf9XAlCZn5hhZXIolXxHHF1VMnZpNFaG6E-QNdl_lOZh_cpRcd4II9zp7Np8fXSwZu0GxWDR8jaJrLQbh4HtjupRlOvhO7GYjYofNE090hFwa_skJfTbGhxJyC0R3zue2eeQ22X2igIQMyQ63S9lU0UGlBVzDxc31qIboASCmf9W6azsdsSNbvHoPC3TkZUMuJR-FSUpf1Bpa_COlEG6u0La4PO7MH6m1WV5alakut2MuIHRwcwSsk_K5lbaBccre-XWwiP07C152sR3rfdHtEqbXDCYcrHzv1Wo71XzmirzAf0vGXKt2Z1oi-yKZ-JGhSQ9XePIh1DADxQ6J_yAkoaZ0mQMfO44OimEJRqgmk4MW3z0MZwLyaDGD7afyObND0-MWqEE6Xf7l6UYoh_89zFAa3p53DqIciaCEC_hZ_FPnB05BS8KJYUm0gxVoeDRi2U5zSq2_KR08m5a3yMORg_cUW4L72ZNkOT1NBjzW3I3m6RcIsXWf4Ul3ifEEwdi4OSxw8ZxUFiYTRikF7Pju2mCMaQVEBuIplTAvyM6eIvZdFq0o9Cnzvby5VWoy-tYye5nRcgmbizl1-0vC7-4dLKNm4pGPac52UXyyNgh7OZyQ1YKHsy6ltlriAPds42NGE0CW5XDQFIbHwcppYYk54YCo61NC6kpH7S5nCRTLcNJ0SWbuyB1_BQnkTUFYBdlvl01tF4eZ0MBcF5Xmd7i3OIXpVacekfam7T29GHH_VAzrtMmXhCwIY-Qo4IlZoApQdChac2E0lL3yq9Un6GKuMV_zvgb2z7rdV2oi0l16i_VoDt6AtMQhehRUZ4LXhbCSTmB2W1pCCiXIYasR2yxvxsONt1Rs7kaYRHdnZUNtpakNJFHvrg7l5gMUNUR80B0VJnwQPBjAAAokVWPFVrmrtXO-0kJRNN-eo9T8kh_T8TXeidVIBdwxb7KEmxrWxi49o_x0SsvMJrlU3vfn4mQc2xLlfmEuiWLj2oJHgEFkbgkMjzuv4ZfQqnHC_lE6KC2vlqkENsGX-Uyh7qKLogiL7-VDDuDkSU6yjN-oHnfwPlN2URUo_Nj4CGKc9qC8tdl-86kdqn-4ebfotjM6bxaaSbdSWd0lh69GQCEBDDi_fE4O3Hw9alYhSFv2anoOJFN-FRK9ECFG3WNgzO0WJCcClAk-7ON01FNJznVx4V2B1webflVYknIpb23FjY952P7FYDZbejNZwjPGbrjB78TnfoC_q_ZWSuhYhs1Oc-yrpJIo5v-RvtZsKRA-V8dpe_oeWQTICbmXaEOhLU9-t-ooXtT1Itux-hzm_HV_g7Q9O_uwXNAw9LmethdQltxr56bGmdTXgD0Nos6vBzfL9b58jP8SBtRrLdFA6FUmSWZMmoxphs26nueWClQGQttipFskIdxFOo7CH34zwdBcDdvJp2bJ01NMyaZaBygDqGpIeDHVUdKK2ZkmhoJB1AjtYrg86y1vPZPahKzJ2haRy9rvfYc9LzWiwXmEmWh2y-49XL74xaP-Jnfs1f9TWnZ6IfQRBRnaFeu2fNLBtT4kP4LSR9YOy0gun3--eKLUrBWKh3Sr36PmVy7D0AxJhZiZSnRFo4lYAa7l8KByWkdpSkSgl_OzEMWt6Dwoh9u_Pm8WLs_Boi3Z0pPRG-4H185RN26cNjVLt2OgsXqtkHh2mMlrDxkhwvGFpbbTgwu2jw-dzJEnDLJSUX6DZNLDNnDGOD5szGBXLyJ4BvOI7YBX39SLG0uUmzIAOcPMpI7UPRM0Mkd5IzYQ_YUECcuEfy0KXGpgYi1g450tucqoLppY9TAf5pmngNHajzSyHHKeA3ippbrbWsWrteRAzoypZNRiS8sRsu9pXM-36EkaxZegYTeY7lbNVob-oh9DJlPuVCW_l_yTFpGdF44FLG801R2yFm6BzRTtTVQlOcy-FQ2yXYAVoir9QamPSB6Cciqd7jkvPyh_E9FVqvY1IVtSi1Hof5Y-TZHTKcxAkv6OI5PwMozIRwBv9mTN4Z517byMj_kI_zaGSoV4e3-fVdzNxhI_8Wb5cHOZobHjRhZV_6m-_ySV6v0JcCGNcAjA1_bozmFPJEgGB9PQ3sFR4hfXMjo9AgaPwo0xFu_7PQuOhESynhTqcoTQAzBdR0K0ObWSHSXMhXRnTP_uHzsSe2sLLcPeE3B97NRCBapTY6RSOjCurNzwIo6rxJ49JjrmK6Jg5Gl5CWpR9FWgmyah9zXW30EizCfOy5rvMCzO77HD65Fy0hrpVr3KFD21HEHi7LsefTB_z0YQp8gAxf0lOP5drClT_9NuvePwxumT4WBXzr1_PXmu4OA0n5GW04Q8mBM7z1Fx5ZnpbRiLhDIMOhXUrfp9FkwbtTQWlcfLSEjGzObVbquKGF1nDJNJRQINkTeM3EmxHanD5RuvB_oV0QVtsrnnZAqwSl4NMm3tVpo9FW7D3rEcTNeyZd1FgLhwpvRMDEusYBTAd9yIhNsaiASCP2CyNh4JVXfGh8y7l_sl-E2PjxLYKYqIFeO9uwu6QrkW9v1FLybvpvJAXXSxSiCjTfytkVlDM8AQ_FCIPhI5DRzF-b7OKStCuB7EDealYN_ka2SescgxZtkojXKkIemgYWm63kXgPJJGFmSks7Pu_9IzFMOWuz-BV3IYP4jqQXTVHXRFB5R3mm_D_SnSbtVUGez8eH6I0gUb8ObppE3GzGIUbfxXcgbo5OiOpsYaSc-yyksMn8NCOKguPg7fJkCx8LRJaKNoDH-AZUz96WggDMZm4vTTR5UBIJP5djDRgAKKrYm4OFAeNk_rqI90lv5y2U88OXZ6X5YF0jMOgoIWxgXTqWtrciiqPqaeSfmWDsuZz5EjRvZrqxCNJhMp_F_0eXq2kiJkOhaEMl7HO221HNR5XMV_mQozKeeBWxpTyW_RWuua9RRU3rRaEU3tXtG-tQfAYMPW2QTG7_5mkdkO6o1jktLVVVB3-rlgOTygE02Ea5X7QRGs9aB9AX8zxrP70_sK06FOE5mzFGWtzDeQ8mSXHbTTxZ5ujMxqcj6R6MViOpjU7P1603RVyG9RrXkg6IPsBRop8CWu93V0W_OeyhOwuqm5h8BqSJAafA1fcl40g0zMBE_fA4784VZUV75hUaOBLzibDOer22ZzS32g2UfxO_ZD3vbVHqJ87T7jkjcaDSGz3pTf3FctJIxE53MkcZfvBjaZE_S4UJm3LAoy3RGQns_v_8W4J-vXQCOenCqsNz24GmVBtOa9aebgkidw8F7h6QsnKja9FJRYou9rm9gOKU9x-czbkua_srpzX0DYAOvpusl3Jc69Uc1umJUZ1Pj6LzeEKipiQQcofrs1a4Y5A7-Jii4btPl5gPnCa7xlhqvOKevUQUMyAq1AD67hCjhHwQu07KflGpFM3qTldvaQDQzfhuhc5v4ywcLAbRBZfhmZyGT1yM22TRoBYNaDIPLcxbv7QiqohreTj2TFy872TCFA2_rgn_sd6V4LlWOzMDsb3G7n5RwgW_QT3Hdmbr9d-o8DYOLJ_3hqFyEBvf4RqWq4ss-1WxXei6_TNCZRXTp3nSeAZxb77YSXtJpszldzGCAxSpko3grwcKBrMAxJnnVXRfWhHUFyhMRe5UPK_6WDoRD2xAjCpOBcxKkIoGoKrKADn4Mosqe5Feg1GbdqqrcX6A47SDL3QzKdYmnb-Bgk-YICYr5UoRvZ7o0vpsRl1DslGQIkL5nGHGJBoMvkjeW1kkDqOHQ5Hs72O5WrwjNDEO0fLypZ3kKLbpUvBIu-siLa_13fM5EGWTiKiWlh_VeM3MX2fi1lfPBarBVy0Ol8DIRYQ5fKrdU4Su7Hhfn6uyb3UtWO6s6DdO-y8zZghLMzDY92GPWaOUa94m4CgNFRfuYQA0YGEAz7VL5bfDzWtr__9ZsKnfSOt1LBhMeDpGZRDlKuS0iDjkrdUUWOjpCkonY1OJyP4ICoA2v_GRsn5yl7LZk52LW2xIEAwZiUFJkP-qZY0zLkGRUtjZCO0joLTaYZhQHrhrraXk1j93rtmRXBUKdw--1_nqpmAm_QKCPDGulHJNHbbAxbLPwJjMX3X2IFI428Us_7HcZ-2ABQTVeCk2WcbNiH7LPL1UUtWsA5fblwJFj9_y_OWQVh_yXespdVZekAzMowzWaGjZ5PN_jKiWVkJyPqzO-1cpgHEBmvj71v-j7dhVx-xHd_z2gFRuvJn7ut6vbwB6kBYTZgt0-Ysyznkfd-jfqG7OEG1yvEDv0z4c2Ew814Sv_GQfK2_IWXEF0o6EiQuyGc9JHJWbpTlJZ6TAGedCwLOWDRsy-eN2gnPW0XhWvEqOlAvY1cP4WN-uwh36J0HgBWHW-YK3CDkDTZyxzN15_b5NnyHvgzL_1ZZ582JVvq5rbe53jpzBH88T9iFsyNEPuqg_vC0INaNesyZXURqNoMpWFXY-Szcz8OVyP00VuAJ_DWVgyff3FzhUXso2p-7rsGgXYwrtegkc9amewctnfsgmXqb6LxUa1ShaFVTScZYy6KG1haohcHCkIIvDpQUjv0Rs8Az0i2qAFQhfjZCVJusuCAL9CzmjyRLZh9o1XRojoRKV2Xsg9Hgvrf9lRxZvOSD-HnKBPdyLrQNKbdMj14RptsFf4lNQQAl7FsGxMPTX3yjenZNlOQYVXsOS8YGvHPBrslojhmf8GCT0jnoJYQwR-DPhIyc44XBKIxgbK5KyRaEWNbKM8W0_bpgJPQWm7EWC5ECpqmN08R7U9pIoN4cHziwn0I0K1oDAUUlCX7viU6lGjl2J631kLnJX2OJuqtCnLJjBKEz8LIFkB8GShMnHXqiUHBdL37sklZb8AgKfODjEkAXCfkrDfkEec5Mm1XhWM7U8ZHmtum8vgdn-Smgf5TN6Y9PAy7DETJI8ZbtSF7jFqIX5hGQcTWg6s0GzYGyenkyiW2sSGHWEQfd2rxYREMoR8tTIa4xGv43UTDQDW0e4waX6SiPAYd-vQFOzw4xTkQfDYK9vVT4apkUboHOYphBVnlIBbuNrCw2jrzLRokE4vd3EDNssGdBhd6fdq9z7HcnXw50oQih0MjNG4U6xU9n6UX87yBNl83URdGrfJoMBPTwkXM-8i4Ls4LlK0KKINnisuJoAxjWX0juc0z9ZMiYxmsnQuzeXXl5rzO8ifqJ7o8xxA9-ezhqxACgzgeAINfbPjlx_FPEOy0sP0vMnNYBkd3apH18akEFPzExeuvvwhZkWwu5pm4oKAJltgERPc6TcVSSzAB3FjH5o-lYM6bXHYmu4Dt6yEwaquz5drOAhvE3VT6XOE7wXHDl_4EcKbPuNB8Zlz9MQwlxf1V6ruLKCAJ2N30MKnmNkujZ6VTRQDXWdrQ8pUn0V7S1zPZTxHMeNom_cVshGEEZNIAmRZQLIVXdPsN9__IZ_mwXS3AOOHjsVoaoven--oYFd5EW95NZ3SvCuFyzu_OkV5uOdEJlyoKXWIhN71ebwK-9aHK7eA7X03WGx4gu78I0AfmgRgBKoCzKaG96kVSWb0TiQqRzrb77R-1JVPDhnDRGzjQkV6p2bf50eY1Hl375MCIz30fRTc05l3Y7Mp0lwJC2cx_8-jGbzbdMOJn-uLvbU7UWSj80_GnIEHY9C4TjSHhaKAiLM4ShR2UUoo0V_Ke1gpUDLCMwTj6j75tUmR6LAe0N_pK1jbRZ7tX7Ywvl7MLIu13hynwkymSprB6or0f2px1eF7nGI4493LuVY2QJ8FbJl1-z3wX0Soz5EgcnJERfnaS5GZwSwL6PFlAkGdugk2ijaKtDK6axFXa9DLPsu8V_l6

class SimpleTreeNode:

    def __init__(self, val, parent):

        self.NodeValue = val
        self.Parent = parent
        self.Children = []

class SimpleTree:

    def __init__(self, root):

        self.Root = root

    def AddChild(self, ParentNode, NewChild):

        if self.Root:
            if type(self.Root.NodeValue) is tuple:
                if type(NewChild.NodeValue) is tuple:
                    NewChild.NodeValue = (NewChild.NodeValue[0], ParentNode.NodeValue[1] + 1)
                else:
                    NewChild.NodeValue = (NewChild.NodeValue, ParentNode.NodeValue[1] + 1)
        else:
            self.Root = ParentNode
            if type(ParentNode.NodeValue) is tuple:
                self.Root.NodeValue = (ParentNode.NodeValue[0], 0)
                if type(NewChild.NodeValue) is tuple:
                    NewChild.NodeValue = (NewChild.NodeValue[0], ParentNode.NodeValue[1] + 1)
                else:
                    NewChild.NodeValue = (NewChild.NodeValue, ParentNode.NodeValue[1] + 1)
        NewChild.Parent = ParentNode
        ParentNode.Children.append(NewChild)

    def DeleteNode(self, NodeToDelete):

        if NodeToDelete is not self.Root:
            NodeToDelete.Parent.Children.remove(NodeToDelete)
        else:
            raise Exception('It is the root node!')

    def GetAllNodes(self):

        if not self.Root:
            return []
        tree = self.Root
        result = []
        result.append(tree)

        def find(tree):

            for node in tree.Children:
                if node.Children:
                    result.append(node)
                    find(node)
                else:
                    result.append(node)

        find(tree)
        return result

    def FindNodesByValue(self, val):

        if not self.Root:
            return []
        tree = self.Root
        result = []
        if type(tree.NodeValue) is tuple:
            if tree.NodeValue[0] == val:
                result.append(tree)

            def find(tree):

                for node in tree.Children:
                    if node.NodeValue[0] == val:
                        result.append(node)
                    if node.Children:
                        find(node)
        else:
            if tree.NodeValue == val:
                result.append(tree)

            def find(tree):

                for node in tree.Children:
                    if node.NodeValue == val:
                        result.append(node)
                    if node.Children:
                        find(node)
                        
        find(tree)
        return result

    def MoveNode(self, OriginalNode, NewParent):

        self.DeleteNode(OriginalNode)
        self.AddChild(NewParent, OriginalNode)

    def Count(self):

        if not self.Root:
            return 0
        tree = self.Root
        counter = [1]

        def find(tree, counter):
            
            for node in tree.Children:
                counter[0] += 1
                if node.Children:
                    find(node, counter)
            return counter

        count = find(tree, counter)
        return count[0]

    def LeafCount(self):

        if not self.Root:
            return 0
        if not self.Root.Children:
            return 1
        tree = self.Root
        counter = [0]

        def find(tree, counter):

            for node in tree.Children:
                if node.Children:
                    find(node, counter)
                else:
                    counter[0] += 1
            return counter

        count = find(tree, counter)
        return count[0]

import unittest

class Test_SimpleTree(unittest.TestCase):

    def test_AddChild(self):

        lst = [b, c, d, e]
        for i in lst:
            test.AddChild(a, i)
            self.assertIn(i, a.Children)

    def test_DeleteNode(self):

        lst = [b, c, d, e]
        for i in lst:
            test.AddChild(a, i)
        for i in lst:
            test.DeleteNode(i)
            self.assertNotIn(i, a.Children)

    def test_FindNodesByValue(self):

        lst = [b, c, d, e]
        for i in lst:
            test.AddChild(a, i)
        for i in range(len(lst)):
            self.assertTrue(test.FindNodesByValue(i))

    def test_MoveNode(self):

        lst = [b, c, d, e]
        for i in lst:
            test.AddChild(a, i)
        test.MoveNode(c, b)
        test.MoveNode(e, d)
        self.assertNotIn(c, a.Children)
        self.assertNotIn(e, a.Children)
        self.assertIn(c, b.Children)
        self.assertIn(e, d.Children)

    def test_Count(self):

        lst = [b, c, d, e]
        for i in lst:
            test.AddChild(a, i)
        self.assertEqual(test.Count(), 5)

    def test_LeafCount(self):

        lst = [b, c, d, e]
        for i in lst:
            test.AddChild(a, i)
        self.assertEqual(test.LeafCount(), 4)

    def tearDown(self):

        test.Root = None
        a.Children = []

if __name__ == '__main__':

    a = SimpleTreeNode(4, None)
    b = SimpleTreeNode(0, None)
    c = SimpleTreeNode(1, None)
    d = SimpleTreeNode(2, None)
    e = SimpleTreeNode(3, None)
    test = SimpleTree(None)
    unittest.main(verbosity=2)
